# Introduction 

# Chassis
The chassis was designed using 3D printing in a way that allows the movement of the wheels with the Ackerman system and supports all electronic and mechanical parts. Additionally, it was divided into two levels.

## Upper Level

The controller (Arduino Mega 2560) was placed on this level, along with the H-bridge (L298N), the ultrasonic sensors (HC-S04) and the Pixy2 camera. 

## Lower Level

All mechanical and power components were placed on this level, including the Ackerman and push system with their respective actuator, as well as the battery and the color sensor.

# Movement
The robot has two independent mechanical parts: the front axle and the rear axle:

## Front Axle

The robot uses an Ackerman system for steering, which allows it to turn smoothly. For this movement, we initially considered precise actuators like stepper motors or servo motors. However, we decided to use an MG995 servomotor, which has a torque of 9 kg.cm at 5V and a suitable speed of 0.2 seconds/60°. This is enough to control steering accurately and overcome the friction generated by the wheels and the robot's weight on them. We chose this system because it provides great maneuverability, makes parking easier, and is simple to control.

## Rear Axle

The rear wheels are driven by an actuator (driving motor) connected to the wheels through a 36mm diameter gear, which meshes with an identical gear mounted on a hexagonal shaft. This system ensures effective power transmission without the need for additional components, unlike circular shafts. The actuator used has a torque of 3.5 kg.cm and a nominal speed of 250 rpm at 12V. However, we decided to use a voltage of 9V, resulting in a speed of 187 rpm, equivalent to a linear speed of 1.37 m/s. 

# Components

## List of electronic components
| Pieces  | Quantity  |
| --- | --- |
| Arduino mega | 1 |
| Pixy2 camera | 1 |
| Ultrasonic Sensor  (HC-SR04) | 3 |
| 170 Point mini breadboard | 1 |
| 10k resistor | 1 |
| H-bridge (L298) | 1 |
| Pull-up button | 1 |
| Dupont cable M/M | 6 |
| Dupont cable M/F  | 14 |
| Motor GA37-520 of 320rpm | 1 |
| Servomotorr MG995 | 1 |
| 9V battery | 1 |
| 194g counterweight | 2 |
| Color sensor (TCS34725) | 1 |

## Battery 
When we purchased a robotics kit, we received a 9V battery. This battery is able to power all the components of the robot, including the controller. The Arduino Mega allows for an operating voltage of 7-12V, so we simply branched the power cables coming from the battery to the Arduino Mega and the bridge.

## Controller (Arduino Mega 2560)
We decided to use a single controller, the Arduino Mega, because it has 54 pins, of which 16 are analog and 12 are PWM signals, and it is compatible with I2C. This allows for the connection of a large number of components if necessary, as well as providing processing capability for large and complex code.

## Color sensor (TCS34725)

[![Esquema-TCS34725.png](https://i.postimg.cc/fW1yQZ8C/Esquema-TCS34725.png)](https://postimg.cc/JtcMbwVH)

We decided to use this sensor because it has a light source, provides information about color or light in RGB and Clear (unfiltered total measurement) values, and features an infrared (IR) light filter, minimizing interference in the reading.

### Code

## Motor GA37-520

[![Medidas-de-motor-GA37-520.jpg](https://i.postimg.cc/90HfTYRS/Medidas-de-motor-GA37-520.jpg)](https://postimg.cc/hzMgRx0b)

The kit we purchased included several useful parts, such as motors, motor mounts, and wheels. Each of the 12V motors could reach a nominal speed of 250 rpm and a torque of 3.5 kg.cm at 12V. Therefore, using a single motor at 9V would be sufficient to provide the necessary speed, control, and tracking, thanks to its encoder, which allows for greater accuracy in the robot's movement on the field.

### Code 
First, we define the variables that go to the H-bridge, which in turn connects to the motor we call `IN1` and `IN2`. We also define 250 as the motor power on a scale of 0 to 255 in the variable `speed`.

```ino
const int IN1 = 3; // Motor control pin
const int IN2 = 4; // Motor control pin
int speed = 250; // Robot speed variable (0-255)
```
The speed will remain constant until the program stops it.

```ino
void setup() {
     // Turn on the motor
    analogWrite(IN1, 0);
    analogWrite(IN2, speed);

    // If the stop time is reached, stop execution
    else if (run && (millis() - startTime >= stopTime)) {
        run = false; // Deactivate execution
        analogWrite(IN1, 0); // Stop the motor
        analogWrite(IN2, 0); // Stop the motor
  }
}
```

## Servomotor (MG995)

[![Medidas-servo-motor-MG995.png](https://i.postimg.cc/JzSCG4BY/Medidas-servo-motor-MG995.png)](https://postimg.cc/gxyT7ps3)

We selected the MG995 servomotor due to its powerful torque in a very compact size. This makes it more effective than its predecessor, providing more precise steering with a torque of 9 kg.cm at 5V.

### Code

To simplify its use, we used the `servo.h` library and created a variable called `servopin` where we placed the pin it occupies, which in this case is pin 5.

```ino
#include "Servo.h" 
const int servoPin = 5; // Servomotor control pin
Servo servoMotor; // Creates a Servo object to control the servomotor
```

We then associated the value of the pin with its corresponding pin using the `servo.attach(servopin)` command and instructed it to move to 78° with the `command servo.write()`, ensuring that it always starts at the initial position.

```ino
void setup() {
  servoMotor.attach(servoPin); // Attach the servo motor to its pin
  servoMotor.write(78); // Initial position of the servo motor
}
```

Throughout the code, this servomotor is used to perform the necessary turns during the challenges.

## Pixy2

This camera can detect seven colors simultaneously. It also features a processor and allows for exporting only the necessary information through different serial ports: UART, SPI, I2C, digital out, or analog. With a shutter speed of 60 fps, continuous movement won't be a problem when detecting colors. It has a horizontal field of view of 60° and a vertical field of view of 40°.

The camera also has adjustable white LEDs for improved color perception. 

### Code

With the camera connected to the Arduino Mega's I2C pins, we add the library `<Pixy2.h>`. We also create a variable called `primercolordetectado` to store the first color detected. To initialize the Pixy2 camera, we use `pixy_init()`. If additional light is needed for color recognition, we use `pixy_setLamp(1, 0)`. This will activate the camera's LED lights.

```ino
#include <Pixy2.h> 
Pixy2 pixy; // Creates a Pixy object for the vision sensor
int firstDetectedColor = 0; // Stores the first color detected by Pixy2

void setup() {
  pixy.init(); // Initialize the Pixy sensor
  pixy.setLamp(1, 0); // Turn on the Pixy's LED
}

```

After teaching the Pixy2 the colors, we create modules for two possibilities. First, we request the colors that the camera has detected with `pixy_ccc.blocks[0].m` and store this information in the variable `primercColorDetectado`.

```ino
void loop() {
    // If there are no objects nearby, check if Pixy detects colors
    else {
      pixy.ccc.getBlocks(); // Request color blocks detected by Pixy
      
      // If Pixy detects at least one color block
      if (pixy.ccc.numBlocks > 0) {
        // If a color hasn't been detected yet, store the first detected color
        if (firstDetectedColor == 0) {
          firstDetectedColor = pixy.ccc.blocks[0].m_signature; // Store the signature of the detected color
        }
      }   
    }
  }
```

If the first detected color is blue, which was previously assigned the value 1, and no obstacles are nearby, the servomotor will turn 50 degrees. This means it will turn to the left.

```ino
        // If the first detected color was blue
        if (firstDetectedColor == 1) {
          // If Pixy detects blue, move the servo motor to the left
          if (pixy.ccc.blocks[0].m_signature == 1) {
            servoMotor.write(50);
          }
          // If Pixy detects orange, wait and return to the initial position
          else if (pixy.ccc.blocks[0].m_signature == 2) {
            delay(1000); // Wait for one second
            servoMotor.write(78);
          }
        }
```

If the first detected color is orange, assigned as 2 in the camera, the servomotor will turn 104º degrees. This means it will turn to the right.

```ino
        // If the first detected color was orange
        else if (firstDetectedColor == 2) {
          // If Pixy detects orange, move the servo motor to the right
          if (pixy.ccc.blocks[0].m_signature == 2) {
            servoMotor.write(104);
          }
          // If Pixy detects blue, wait and return to the initial position
          else if (pixy.ccc.blocks[0].m_signature == 1) {
            delay(1000); // Wait for one second
            servoMotor.write(78);
          }
        }
```

Similarly, in the closed challenge, instead of crossing when it detects lines, it was instructed to cross to the right if the value is red and to the left if the value is green. It's important to note that it must first identify which color has the lowest 'y' position. This tells us which obstacle is closest to the robot, and we store this as the `index`.

```ino
    for (int i = 0; i < blocks; i++) { // Scrolls through all detected blocks
      if (pixy.ccc.blocks[i].m_signature == 1 || pixy.ccc.blocks[i].m_signature == 2) { // If the block is red (1) or green (2)
        if (pixy.ccc.blocks[i].m_y > maxY) { // Si la coordenada Y del bloque actual es mayor que maxY
          maxY = pixy.ccc.blocks[i].m_y; // Actualiza maxY
          index = i; // Stores the block index with the largest Y
        }
      }
    }
```

After obtaining the desired value, we store its 'x' and 'y' coordinates with `int x = pixy.ccc.blocks[index].m * Y` and `int y = pixy.ccc.blocks[index].m` respectively. We also store the color with the `signature` which will have a value of 1 for red and 2 for green.

Next, based on the 'x' coordinate of our desired value, we assign a degree between 0° and 180°, allowing the robot to follow the obstacle.

```ino
      targetPosition = map(x, 0, 319, 0, 180); // Map the X coordinate to a range from 0 to 180 degrees.
      myservo.write(targetPosition); // Moves the servomotor to the target position.
```

Through various tests, we determined that when the desired value is in 'y' coordinates greater than or equal to 142 and less than or equal to 180 `(y >= 142 && y <= 180)`, if its color is green ((signature == 1)), the robot will move to the left with the servomotor at 50°, followed by certain adjustments.

```ino
 if (y >= 142 && y <= 180) { // If the block is within a certain area of interest in the screen// If the block is green (1)
  if (signature == 1) { 
     myservo.write(50); // Moves the servomotor to the lef
     delay(800); // Wait 800 milliseconds
     myservo.write(115); // Moves the servomotor to the right
     delay(900); // Wait 900 milliseconds
     myservo.write(60); // Ajusta el servomotor para volver a la posición recta
    delay(400); // Wait 400 milliseconds
    myservo.write(78); // Returns the servomotor to the initial position
    }
 }
```

The same happens if the color is red `((signature == 2))`. The servomotor will move to 110° and then perform angle adjustments.

```ino
else if (signature == 2) { // If the block is red (2)
          myservo.write(110); // Moves the servomotor to the right
          delay(1000); // Wait 1000 milliseconds
          myservo.write(60); // Adjusts the servomotor to return to the straight position.
          delay(500); // Wait 500 milliseconds
          myservo.write(78); // Returns the servomotor to the initial position 
        }
```

## Ultrasonic Sensors (HC-S04)

[![Medidas-de-sensor-ultrasonido-HC-SR04.jpg](https://i.postimg.cc/KvsN21dV/Medidas-de-sensor-ultrasonido-HC-SR04.jpg)](https://postimg.cc/bskb0wYH)

Ultrasonic sensors allow us to calculate distances. They work with ultrasonic waves, where there's an emitter that transmits the wave and a receiver that detects the sent wave. This allows us to calculate the distance based on the time it takes for the wave to bounce back. These sensors provide the robot with an understanding of its location on the field, as they have a maximum detection range of 4.5m, and the field is 3x3m. They also help determine if a collision is imminent and allow the robot to avoid obstacles.

### Code

To facilitate the conversion of the received wave frequency to cm, we use the library `<ultrasonic.h>`. We then define the pins of each sensor with `ultrasonic` and the name we give the sensor followed by `(trig, echo)`.

```ino
#include <Ultrasonic.h> 
Ultrasonic ultrasonicIzquierdo(6, 7); // Ultrasonic sensor left (trigger, echo)
Ultrasonic ultrasonicDerecho(8, 9); // Ultrasonic sensor
```

Immediately after starting the program, we read the distance given by the sensors and store it in the variables `distanciaIzquierda` and `distanciaDerecha` respectively.

```ino
void loop() {
  if (ejecutar && (millis() - tiempoInicio < tiempoDetencion)) {
    // Main code that is executed after pressing the button
    int distanciaIzquierda = ultrasonicIzquierdo.read(); // Lee la distancia del sensor izquierdo
    int distanciaDerecha = ultrasonicDerecho.read(); // Reads the distance of the right sensor
  }
}  
```

If the left sensor detects an obstacle between 3cm and 12cm, the servomotor will move to 104°. After half a second, it will make a correction to 60° to return to its original position of 78°.

```ino
 // If there is an object near the left sensor, move the servomotor.
    if (distanciaIzquierda >= 3 && distanciaIzquierda <= 12) {
      servoMotor.write(104); // Turn right 
      delay(500); // Espera medio segundo
      servoMotor.write(60); // Turn left to level
      delay(200); // Wait 200 milliseconds
      servoMotor.write(78); // Returns to initial position
    }
```

If the same occurs on the right side of the sensor, the servomotor will move to 50°. After half a second, it will make a correction to 120° to return to its original position of 78°.

```ino
 // Si hay un objeto cerca del sensor derecho, mueve el servomotor
    else if (distanciaDerecha >= 3 && distanciaDerecha <= 12) {
      servoMotor.write(50); // Turn left 
      delay(500); // Wait half a second
      servoMotor.write(120); // Turn right to level
      delay(200); // Wait 200 milliseconds
      servoMotor.write(78); /// Returns to initial position
    } 
```
